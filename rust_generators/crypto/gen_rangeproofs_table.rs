// Generate rangeproofs generator tables for Avatar (C code)
// Uses the same algorithm as bulletproofs crate
// Run: cd ~/tos-spec/rust_generators/crypto && cargo run --release --bin gen_rangeproofs_table > rangeproofs_table.c

use bulletproofs::PedersenGens;
use curve25519_dalek_ng::ristretto::RistrettoPoint;
use curve25519_dalek_ng::traits::Identity;
use sha3::{Shake256, digest::{ExtendableOutput, Update, XofReader}};

const NUM_GENERATORS: usize = 256;

// Recreate bulletproofs' GeneratorsChain
fn generators_chain(label: &[u8], count: usize) -> Vec<RistrettoPoint> {
    let mut shake = Shake256::default();
    shake.update(b"GeneratorsChain");
    shake.update(label);
    let mut reader = shake.finalize_xof();

    let mut result = Vec::with_capacity(count);
    for _ in 0..count {
        let mut uniform_bytes = [0u8; 64];
        reader.read(&mut uniform_bytes);
        result.push(RistrettoPoint::from_uniform_bytes(&uniform_bytes));
    }
    result
}

// Convert RistrettoPoint to extended coordinates for C code
// Avatar uses at_ristretto255_point_t which has X, Y, Z, T in fe_loose format
fn point_to_c_struct(p: &RistrettoPoint, comment: &str) -> String {
    let compressed = p.compress();
    let compressed_hex = hex::encode(compressed.as_bytes());

    // Decompress to get extended coordinates
    // We need to output the internal representation
    // For now, output compressed form and let Avatar decompress at runtime
    // Actually, Avatar's tables store decompressed extended points

    // The internal representation is complex. Let's just output compressed form
    // and create a simpler table format that Avatar can load.
    format!("  // compressed: 0x{}\n", compressed_hex)
}

fn main() {
    let pc_gens = PedersenGens::default();

    // Generate G_vec for party 0 (single party range proofs)
    let label_g: [u8; 5] = [b'G', 0, 0, 0, 0];
    let g_points = generators_chain(&label_g, NUM_GENERATORS);

    // Generate H_vec for party 0
    let label_h: [u8; 5] = [b'H', 0, 0, 0, 0];
    let h_points = generators_chain(&label_h, NUM_GENERATORS);

    println!("/* Bulletproofs-compatible generator tables for Avatar rangeproofs");
    println!("   Generated by gen_rangeproofs_table.rs");
    println!("   These generators match the bulletproofs crate exactly. */");
    println!();

    // Output basepoint G (same as before)
    println!("/* Pedersen basepoint G (ristretto255 basepoint) */");
    println!("static const uchar at_rangeproofs_basepoint_G_compressed[32] = {{");
    print!("  ");
    for (i, b) in pc_gens.B.compress().as_bytes().iter().enumerate() {
        print!("0x{:02x}", b);
        if i < 31 { print!(", "); }
        if (i + 1) % 8 == 0 && i < 31 { print!("\n  "); }
    }
    println!("\n}};");
    println!();

    // Output basepoint H (blinding)
    println!("/* Pedersen basepoint H (blinding generator) */");
    println!("static const uchar at_rangeproofs_basepoint_H_compressed[32] = {{");
    print!("  ");
    for (i, b) in pc_gens.B_blinding.compress().as_bytes().iter().enumerate() {
        print!("0x{:02x}", b);
        if i < 31 { print!(", "); }
        if (i + 1) % 8 == 0 && i < 31 { print!("\n  "); }
    }
    println!("\n}};");
    println!();

    // Output G generators (compressed)
    println!("/* Bulletproof generators G (compressed) */");
    println!("static const uchar at_rangeproofs_generators_G_compressed[{}][32] = {{", NUM_GENERATORS);
    for (i, g) in g_points.iter().enumerate() {
        let bytes = g.compress();
        print!("  {{ ");
        for (j, b) in bytes.as_bytes().iter().enumerate() {
            print!("0x{:02x}", b);
            if j < 31 { print!(", "); }
        }
        print!(" }}");
        if i < NUM_GENERATORS - 1 { print!(","); }
        println!(" /* G[{}] */", i);
    }
    println!("}};");
    println!();

    // Output H generators (compressed)
    println!("/* Bulletproof generators H (compressed) */");
    println!("static const uchar at_rangeproofs_generators_H_compressed[{}][32] = {{", NUM_GENERATORS);
    for (i, h) in h_points.iter().enumerate() {
        let bytes = h.compress();
        print!("  {{ ");
        for (j, b) in bytes.as_bytes().iter().enumerate() {
            print!("0x{:02x}", b);
            if j < 31 { print!(", "); }
        }
        print!(" }}");
        if i < NUM_GENERATORS - 1 { print!(","); }
        println!(" /* H[{}] */", i);
    }
    println!("}};");

    // Print verification info to stderr
    eprintln!("Generated {} G generators and {} H generators", NUM_GENERATORS, NUM_GENERATORS);
    eprintln!("G[0] = {}", hex::encode(g_points[0].compress().as_bytes()));
    eprintln!("H[0] = {}", hex::encode(h_points[0].compress().as_bytes()));
}
