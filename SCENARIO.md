# TOS Scenario/Expected Comparison Framework

## Goal
Define a deterministic, executable **scenario + expected** framework so that TOS clients
can be tested in a uniform, repeatable way across single-client and multi-client runs.

## Core Constraints
- **Fixtures are the spec truth**: pytest-generated JSON produced by the executable spec.
- **Vectors are runnable**: machine-executable JSON derived from fixtures.
- **Simulators own assertions**: they execute vectors and verify expected results.
- **Harness only orchestrates**: starts containers, aggregates logs/results.
- **Determinism**: same inputs produce the same outputs across clients.

## Directory Roles & Ownership
- `fixtures/` (spec-owned)
  - Source of truth for scenarios and expected behavior.
  - Generated by pytest from the executable spec.
  - YAML files are documentation only and are mirrored into JSON as `runnable: false`.
- `vectors/` (harness-owned consumption)
  - Runnable scenarios derived from fixtures.
  - JSON is the primary format.
- `tools/`
  - Conversion pipeline `fixtures -> vectors`.
  - Validation/report tooling.
- `~/labu/simulators/tos/`
  - Execution engines that consume vectors and assert expected results.

## Vector Schema (JSON)

```json
{
  "name": "string",
  "description": "string",
  "pre_state": {
    "network_chain_id": 0,
    "global_state": {
      "total_supply": 0,
      "total_burned": 0,
      "total_energy": 0,
      "block_height": 0,
      "timestamp": 0
    },
    "accounts": [
      { "address": "hex", "balance": 0, "nonce": 0, "frozen": 0, "energy": 0, "flags": 0, "data": "" }
    ],
    "escrows": [],
    "arbiters": [],
    "kyc_data": [],
    "committees": [],
    "agent_accounts": [],
    "tns_names": [],
    "referrals": [],
    "energy_resources": [],
    "contracts": [],
    "arbitration_commit_opens": [],
    "arbitration_commit_vote_requests": [],
    "arbitration_commit_selections": []
  },
  "input": {
    "kind": "tx | block | rpc",
    "wire_hex": "...",
    "rpc": { "method": "...", "params": {} },
    "tx": { }
  },
  "expected": {
    "success": true,
    "error_code": 0,
    "state_digest": "hex32",
    "post_state": {
      "global_state": { },
      "accounts": [ ]
    }
  }
}
```

All `pre_state` domain fields (escrows, arbiters, etc.) are optional and default
to empty lists when omitted. They provide the initial domain-specific state that
certain transaction types require (e.g., escrow operations need an existing escrow
in `escrows`, contract invocations need a deployed contract in `contracts`).

## Simulator Behavior
- **Single-client mode**:
  - Execute scenario against one client.
  - Compare `expected` directly (account-level, global state, error codes).
- **Multi-client mode**:
  - Execute scenario against all clients.
  - Verify each client matches `expected`.
  - Also check cross-client consistency.

## Execution Flow
1. Author/maintain fixtures in `fixtures/`.
2. Convert fixtures to vectors via `tools/fixtures_to_vectors.py`.
3. Simulators read vectors and execute against clients.
4. Expected results are asserted by simulators.
5. Harness aggregates logs and produces report output.

## Verification Strategy
- **Required assertions**:
  - `expected.success`
  - `expected.error_code`
- **Recommended assertions**:
  - `expected.post_state` (account-level, field-by-field)
  - `expected.global_state`
  - `expected.state_digest`
- **Optional assertions**:
  - Events, receipts, or additional protocol-specific outputs.

## State Digest
The state digest must be deterministic across implementations. The canonical definition is
implemented in `src/tos_spec/state_digest.py` and is derived from `post_state`.

### State Digest v1 (Canonical)
**Hash**: BLAKE3-256  
**Encoding**: binary, fixed-width numeric fields (u64 big-endian)  

**Inputs**
- `post_state.global_state` fields:
  - `total_supply`, `total_burned`, `total_energy`, `block_height`, `timestamp`
- `post_state.accounts` list

**Canonical ordering**
1. Global state fields in the exact order listed above.
2. Accounts sorted by `address` (32-byte value, ascending).

**Account encoding (per account, in order)**
1. `address` (32 bytes, hex -> bytes)
2. `balance` (u64 BE)
3. `nonce` (u64 BE)
4. `frozen` (u64 BE)
5. `energy` (u64 BE)
6. `flags` (u64 BE)
7. `data_len` (u64 BE)
8. `data` bytes (hex -> bytes, length = `data_len`)

**Global state encoding**
Each field is encoded as a u64 BE in the order listed above.

**Digest result**
- `state_digest` is the hex-encoded 32-byte BLAKE3 output of the full canonical encoding.

## Notes
- Vectors are JSON-first to minimize ambiguity and maximize tooling support.
- Fixtures are JSON generated by pytest. YAML specs remain as documentation and are mirrored into JSON
  as `runnable: false` vectors for unified consumption.
